/*
 * Traffic generator
 *
 *   Addy Bombeke <addy.bombeke@ugent.be>
 *   Dimitri Staessens <dimitri.staessens@intec.ugent.be>
 *   Douwe De Bock <douwe.debock@ugent.be>
 *
 * This source code has been released under the GEANT outward license.
 * Refer to the accompanying LICENSE file for further information
 */

#include <time.h>
#include <signal.h>
#include <time.h>
#include <string.h>
#include <endian.h>
#include <sstream>
#include <fstream>
#include <errno.h>

#include <iostream>
#include <boost/thread.hpp>

#define RINA_PREFIX "traffic-generator"
#include <librina/logs.h>

#include "server.h"
#include "timeutils.h"


using namespace std;
using namespace rina;

void server::set_interval(unsigned int interval)
{
	this->stat_interval = interval;
}

void server::set_output_path(string& path)
{
	this->output_path=path;
}


void server::run()
{
	for(;;) {
		IPCEvent * event = ipcEventProducer->eventWait();
		int	   port_id = 0;

		if (!event)
			return;

		switch (event->eventType) {

		case REGISTER_APPLICATION_RESPONSE_EVENT:
			ipcManager->commitPendingRegistration(
				event->sequenceNumber,
				dynamic_cast<RegisterApplicationResponseEvent*>(event)->DIFName);
			break;

		case UNREGISTER_APPLICATION_RESPONSE_EVENT:
			ipcManager->appUnregistrationResult(
				event->sequenceNumber,
				dynamic_cast<UnregisterApplicationResponseEvent*>(event)->result == 0);
			break;

		case FLOW_ALLOCATION_REQUESTED_EVENT: {
			rina::FlowInformation flow = ipcManager->allocateFlowResponse(
				*dynamic_cast<FlowRequestEvent*>(event), 0, true);
			LOG_INFO("New flow allocated [port-id = %d]", flow.portId);
			boost::thread t(&server::handle_flow, this, flow.portId, flow.fd);
			t.detach();
			break;
		}
		case FLOW_DEALLOCATED_EVENT:
			port_id = dynamic_cast<FlowDeallocatedEvent*>(event)->portId;
			ipcManager->flowDeallocated(port_id);
			LOG_INFO("Flow torn down remotely [port-id = %d]", port_id);
			break;

		default:
			LOG_INFO("Server got new event of type %d",
				 event->eventType);
			break;
		}
	}
}

void server::handle_flow(int port_id, int fd)
{
	/* negotiate test with client */
	unsigned long long count;
	unsigned int	   duration; /* it arrives in ms */
	unsigned int	   sdu_size;

	/* FIXME: clean up this junk ---> */
	/* receive test parameters from client */
	char initData[sizeof(count) + sizeof(duration) + sizeof(sdu_size) + 32];
	int ret;

	ret = read(fd, initData,
		   sizeof(count) + sizeof(duration) + sizeof(sdu_size) + 32);
	if (ret < 0) {
		LOG_ERR("read() failed: %s", strerror(errno));
		return;
	}

	memcpy(&count, initData, sizeof(count));
	memcpy(&duration, &initData[sizeof(count)], sizeof(duration));
	memcpy(&sdu_size, &initData[sizeof(count) + sizeof(duration)], sizeof(sdu_size));

	count = be64toh(count);
	duration = be32toh(duration);
	sdu_size = be32toh(sdu_size);

	char response[] = "Go ahead!						   ";
	struct timespec start;

	ret = write(fd, response, sizeof(response));
	if (ret != (int)sizeof(response)) {
		LOG_ERR("write() failed: %s", strerror(errno));
		return;
	}

	/* <--- FIXME */

	char data[sdu_size];
	bool		   stop		   = false;
	bool		   timed_test	   = (duration > 0);
	unsigned long long sdus		   = 0; /* total # sdus in test */
	unsigned long long sdus_intv	   = 0; /* # sdus up to previous interval */
	unsigned long long bytes_read	   = 0; /* total bytes read */
	unsigned long long bytes_read_intv = 0; /* bytes read up to previous interval */
	string             csv_fn          = output_path;
	string             client_apn_api  =
		ipcManager->getFlowInformation(port_id).remoteAppName.
		getProcessNamePlusInstance();
	ofstream           ofs;

	struct timespec	   end;	     /* end of test */
	struct timespec	   intv;     /* reporting interval */
	struct timespec	   iv_start; /* start reporting intv */
	struct timespec	   iv_end;   /* reporting deadline */
	struct timespec	   now;

	LOG_INFO("Starting test from client %s on port-id %lu", client_apn_api.c_str(), port_id);
	LOG_INFO("Duration: %u s, count: %llu sdus, sdu size: %u bytes, reporting interval: %u ms",
		 duration/1000, count, sdu_size, stat_interval);

        /* to be removed when tgen supports non-blocking I/O */
	if (timed_test && !csv_fn.empty()) {
			LOG_INFO("File output is currently disabled for timed tests");
			csv_fn = "";
	}
	if (!csv_fn.empty()) {
		/* construct log file name */
		ostringstream os;
                long t = time(NULL);
		os << csv_fn;
		if (csv_fn[csv_fn.length()-1]!='/')
			os << '/';
		os << "tgen."
		   << client_apn_api
		   << "."
		   << port_id
		   << "."
		   << t
		   <<".csv";
		csv_fn = os.str();
		LOG_INFO("Writing output of this session to %s", csv_fn.c_str());
		/* write first line of the csv file */
		ofs.open(csv_fn.c_str());
		ofs << "# Generated by rina-tgen server at " << ctime(&t);
		ofs << "# connection from " << client_apn_api << " on port-id " << port_id << endl << endl;
		ofs << "interval (s), # sdu's, #bytes, packet rate (p/s), bitrate (Mb/s)" << endl;
	}

	clock_gettime(CLOCK_REALTIME, &start);
	if (timed_test) {
		intv.tv_sec = duration/1000; /* tv_sec expects seconds */
		ts_add(&start, &intv, &end);
		if (!count)
			count=(unsigned long long) -1LL;
	}
	/* set reporting interval */
	intv.tv_sec = stat_interval/1000;
	intv.tv_nsec = (stat_interval%1000)*MILLION;
	ts_add(&start, &intv, &iv_end); /* next deadline for reporting */
	clock_gettime(CLOCK_REALTIME, &iv_start);
	while (!stop) {
		int ret;
		clock_gettime(CLOCK_REALTIME, &now);
		ret = read(fd, data, sdu_size);
		if (ret < 0) {
			LOG_ERR("read() failed: %s", strerror(errno));
			return;
		}
		bytes_read += ret;
		sdus++;
		if (!timed_test && sdus >= count)
			stop = true;
		if (timed_test && (sdus >= count || ts_diff_us(&now,&end) < 0))
			stop = true;
		if (stat_interval && (stop || ts_diff_us(&now, &iv_end) < 0)) {
			int us = ts_diff_us(&iv_start, &now);
			LOG_INFO("Port %4d: %9llu SDUs (%12llu bytes) in %12lu us => %9.4f p/s, %9.4f Mb/s",
					port_id,
					sdus-sdus_intv,
					bytes_read-bytes_read_intv,
					us,
					((sdus-sdus_intv) / (float) us) * MILLION,
					8 * (bytes_read-bytes_read_intv) / (float)us);
			if (!csv_fn.empty()) /* write to output file */
				ofs << us << ","
					<< sdus-sdus_intv << ","
					<< bytes_read-bytes_read_intv << ","
					<< ((sdus-sdus_intv) / (float) us) * MILLION << ","
					<< 8 * (bytes_read-bytes_read_intv) / (float)us << endl;
			iv_start=iv_end;
			sdus_intv = sdus;
			bytes_read_intv = bytes_read;
			ts_add(&iv_start, &intv, &iv_end); /* end time for next interval */
		}
	}
	clock_gettime(CLOCK_REALTIME, &end);
	long ms = ts_diff_ms(&start, &end);
	/* FIXME: removed until we have non-blocking read()
	   unsigned int nms = htobe32(ms);
	   unsigned long long ncount = htobe64(totalSdus);
	   unsigned long long nbytes = htobe64(totalBytes);

	   char statistics[sizeof(ncount) + sizeof(nbytes) + sizeof(nms) + 64];
	   memcpy(statistics, &ncount, sizeof(ncount));
	   memcpy(&statistics[sizeof(ncount)], &nbytes, sizeof(nbytes));
	   memcpy(&statistics[sizeof(ncount) + sizeof(nbytes)], &nms, sizeof(nms));

	   write(fd, statistics, sizeof(statistics) + 64);
	   */

	LOG_INFO("Port %4d: %9llu SDUs, %12llu bytes in %9ld ms, %4.4f Mb/s",
			port_id, sdus, bytes_read, ms, (bytes_read * 8.0) / (ms * 1000));
	if (ofs.is_open())
		ofs.close();
}
